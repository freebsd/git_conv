#!/bin/sh

svn=${1:-base}
git=${2:-freebsd-base.git}
branch=${3:-master}

export GIT_DIR=$git

git log --reverse --max-parents=1 --grep="This commit was generated by cvs2svn to compensate" --format=%h $branch |
    while read ref; do
        parent=`git show -s --format=%p $ref`
        tree=`git show -s --format=%T $ref`
        ptree=`git show -s --format=%T $parent`
        if [ "$tree" = "$ptree" ]; then
            svn_rev=`git show -s --format=%N $ref | sed -n '1s/.*revision=//p'`
cat <<EOS
match /head/
  min revision $svn_rev
  max revision $svn_rev
end match
EOS
        fi
    done

# Print empty git commits, where the tree object being pointed to is the same
# as the parent commit, so there is no diff introduced. Print the svn log and
# diff for these revisions too, sometimes they delete directories or touch up
# svn metadata like keywords, mimetypes or mergeinfo.
# Actually, more often than not it prints forced commits to denote a repo-copy.
# We could use this information to patch up some of them. e.g. the first
# repo-copy it identifies is r167568 and this is nicely visible in a git log
# output as well.
git log --max-parents=1 --pretty=format:'%t %ad %N' $branch | sed '/^$/d' |
    awk 'BEGIN{parent=0} { if ($1 == parent) { print "Empty commit found: " prev }; parent=$1; prev=$0}' |
    sed -e 's/.*=//' |
    while read rev; do
	svn log -vc$rev file:///$PWD/$svn;
	svn diff -c$rev file:///$PWD/$svn|head;
    done
